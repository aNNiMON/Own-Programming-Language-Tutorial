# Pattern Matching (сопоставление с образцом)

Оператор `match` позволяет выполнить сопоставление значения с образцом.

@[code](../../code/basics/pattern_matching1.own)

@[code](../../code/basics/pattern_matching2.own)

Проверяется тип и значение. Если ни одна из веток `case` не обнаружила совпадение, выполняется тело ветки `case _`.


Помимо константных значений, в `case` может присутствовать имя переменной.

@[code](../../code/basics/pattern_matching3.own)

В таком случае возможен один из двух сценариев:

1.  Переменная уже определена. Сравнивается её значение.
2.  Переменная не определена. Ей присваивается сопоставляемое значение и выполняется ветка `case`.

В примере выше, интерпретатор видит первые две ветки так:

```own
case 10: 
case 20:
```

Для последней ветки переменная `c` не определена, поэтому выполнится присваивание `c = x`, после чего вызов передаётся телу ветки `case c`.


## Уточнения

Ветка `case` может иметь дополнительное сравнение

@[code](../../code/basics/pattern_matching4.own)


## Сопоставление массивов

Для сопоставления элементов массивов, в блоке case используется следующий синтаксис:

*   `case []:` выполняется, если в массиве нет элементов
*   `case [a]:` выполняется, если в массиве есть один элемент
*   `case [a :: b]:` выполняется, если в массиве есть два и более элементов
*   `case [a :: b :: c :: d :: e]:` выполняется, если в массиве есть пять и более элементов

Для двух последних случаев справедливы такие правила:

*   Если количество переменных в списке совпадает с количество элементов массива, то всем переменным присваивается значение массива.

```own
match [0, 1, 2] {
  case [x :: y :: z]: // x = 0, y = 1, z = 2
}
```

*   Если элементов массива больше, то в последней переменной будут сохранены оставшиеся элементы массива.

```own
match [0, 1, 2, 3, 4] {
  case [x :: y :: z]: // x = 0, y = 1, z = [2, 3, 4]
}
```

Пример рекурсивного вывода элементов массива

@[code](../../code/basics/pattern_matching5.own)


## Сопоставление значений массивов

Для сопоставления значений элементов массивов, используется синтаксис:

*   `case (expr1, expr2, expr3):` выполняется, если в массиве есть 3 элемента и первый элемент равен результату выражения expr1, второй - результату expr2 и третий - результату expr3.
*   `case (expr1, _):` выполняется, если в массиве есть 2 элемента и первый элемент равен результату выражения expr1, а результат второго не важен.

Классическая задача FizzBuzz может быть решена с использованием Pattern Matching:

@[code](../../code/basics/pattern_matching6.own)
